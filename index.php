<?php
/*1. Создать структуру классов ведения товарной номенклатуры.
а) Есть абстрактный товар.
б) Есть цифровой товар, штучный физический товар и товар на вес.
в) У каждого есть метод подсчета финальной стоимости.
г) У цифрового товара стоимость постоянная – дешевле штучного товара в два раза. У штучного товара обычная стоимость, у весового – в зависимости от продаваемого количества в килограммах. У всех формируется в конечном итоге доход с продаж.
д) Что можно вынести в абстрактный класс, наследование?
2. *Реализовать паттерн Singleton при помощи traits.*/

abstract class Product {
    abstract public function getPrice();
    
    abstract public function getFinalPrice();
    
    public function getProfit() {

    }
}

class pieceGood extends Product {
    protected $price;

    public function getPrice() {

    }
    public function getFinalPrice() {

    }
}

class electronGood extends pieceGood {
    protected $price;
    
    public function getPrice() {

    }

}

class weightGood extends Product {
    protected $price;

    public function getPrice() {

    }
    public function getFinalPrice() {

    }
}

/* 
Исходя из условия "У цифрового товара стоимость постоянная – дешевле штучного товара в два раза" - принимаем, что
цифровой товар - это тот же штучный товар, только в 2 раза дешевле (в силу отсутствия отдельных видов расходов продавца).
Логика структуры следующая:
1. У любого вида товара должен быть метод получения цены единицы товара для покупателя - getPrice(),
но он будет разный в зависимости от типа товара:
- у штучного товара цена товара соответствует базовой цене;
- у электронного товара цена соответствует базовой цене, уменьшенной в 2 раза;
- у весового товава цена соответствует базовой цена за единицу веса.
2. У любого вида товара должен быть метод получения итоговой цены товара за покупку - getFinalPrice(),
но он будет разный в зависимости от типа товара, однако в данном случае у электронного товара метод расчета
итоговой цены товара не будет отличаться от штучного товара - нужно взять цену товара, полученную getPrice(),
и умножить на количество товара, поэтому метом getFinalPrice() в классе electronGood не переопределяем.
3. Метод getProfit() для любого товара одинаковый, итоговый доход для любого товара будет равняться разнице между
ценой продажи за весь товар и ценой покупки за весь товар.